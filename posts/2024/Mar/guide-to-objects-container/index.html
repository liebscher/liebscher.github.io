<!DOCTYPE html>
<html lang="en">

<head>
         <title>Alex Liebscher - Guide to Simulating Objects in aÂ Container</title>
       <meta charset="utf-8" />
       <meta name="description" content="">
       <meta name="viewport" content="width=device-width, initial-scale=1" />
       <meta name="generator" content="Pelican" />

       <link href="/feeds/all.atom.xml"
              type="application/atom+xml" rel="alternate" title="Alex Liebscher Full Atom Feed" />
       <link href="/feeds/meta.atom.xml"
              type="application/atom+xml" rel="alternate" title="Alex Liebscher Categories Atom Feed" />




    <meta name="tags" content="javascript" />
    <meta name="tags" content="physics" />


       <!-- UIkit CSS -->
       <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.10.0/dist/css/uikit.min.css" />

       <!-- UIkit JS -->
       <script src="https://cdn.jsdelivr.net/npm/uikit@3.10.0/dist/js/uikit.min.js"></script>
       <script src="https://cdn.jsdelivr.net/npm/uikit@3.10.0/dist/js/uikit-icons.min.js"></script>

       <link rel="preconnect" href="https://fonts.googleapis.com">
       <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
       <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif:ital,wght@0,200;0,400;0,600;1,400&family=Playfair+Display:wght@400;600&display=swap"
              rel="stylesheet">

       <link rel="stylesheet" type="text/css" href="/theme/css/default.css" />
       <link rel="stylesheet" type="text/css" href="/theme/css/style.css" />

       <!-- favicon licensing -->
       <!-- Copyright 2020 Twitter, Inc and other contributors (https://github.com/twitter/twemoji) -->
       <!-- License: CC-BY 4.0 (https://creativecommons.org/licenses/by/4.0/) -->
       <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
       <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
       <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
       <link rel="icon" type="image/png" href="/favicon.ico">

       <script data-goatcounter="https://liebscher.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</head>

<body>
       <header class="uk-section uk-section-small">
              <div class="uk-container uk-width-2-3@m uk-margin-auto">
                     <!-- show a bigger name on mobile -->
                     <h1 class="uk-heading uk-text-center uk-visible@s">
                            <a href="/">Alex Liebscher</a>
                     </h1>
                     <h1 class="uk-heading-medium uk-text-center uk-hidden@s">
                            <a href="/">Alex Liebscher</a>
                     </h1>
                     <!-- 
 -->
              </div>
       </header>
<section class="uk-section uk-section-xsmall uk-width-2-3@m uk-margin-auto">
  <div class="uk-container uk-text-justify">
    <ul class="uk-breadcrumb">
      <li><a href="/index.html">Home</a></li>
      <li><span>Guide to Simulating Objects in a&nbsp;Container</span></li>
    </ul>
  </div>
</section>
<section class="uk-section uk-background-cover" style="background-image: url(/images/unsplash-header-bg.jpg)">
  <div class="uk-container uk-width-2-3@m">
    <header class="uk-text-center">
      <h1 class="uk-h1">Guide to Simulating Objects in a&nbsp;Container</h1>
      <p><p>Do smaller objects (like small apple slices) always fit better in a container than larger objects (like big apple&nbsp;slices)?</p></p>
    </header>
    <footer class="uk-text-center uk-margin">
      <time datetime="2024-03-24T00:00:00-07:00">
        Sun 24 March 2024
      </time>
      <div>
        Tags:
        <a href="/tag/javascript.html">javascript</a>, 
        <a href="/tag/physics.html">physics</a>
      </div>
    </footer>
  </div>
</section>
<section class="uk-section">
  <div class="uk-container uk-width-expand uk-width-2-3@m uk-text-justify">
    <p>I was thinking the other day about whether it&#8217;s always more space efficient to pack smaller apple slices in a Tupperware container compared to larger ones. If that were true, and we run into issues fitting things like apple slices in their containers, we should just adopt the habit of cutting those slices&nbsp;smaller.</p>
<p>Likewise, maybe when packing moving boxes, trying to break down objects, like side tables or ottomans or vacuums, into smaller component pieces in order to fit them into your&nbsp;boxes.</p>
<p>This had me thinking for an afternoon, until I brought up the question to my partner Kailyn who quickly surmised that this was simply integration in three dimensions! An explanation of this at the end. By then though I had day-dreamed something like a simulation-based computational method for &#8220;throwing&#8221; virtual apple slices in a virtual container and measuring how compact they&nbsp;get.</p>
<p>I thought it&#8217;d be a good learning experience to try to see this through just a bit, even if I thought I already knew the&nbsp;answer.</p>
<h2>A Virtual&nbsp;World</h2>
<p>To simulate throwing apple slices in a container, we need a place to do such throwing. I imagined this would be some virtual world with a physics engine. I started Googling Python physics engines, but realized it&#8217;d probably be easier to try this problem in a web browser. A web browser has much greater visual support than Python, in my opinion. A web browser also runs JavaScript, which I figured would have a ready-to-go physics engine&nbsp;library.</p>
<h3>Discovering&nbsp;Matter.js</h3>
<p>A quick search turned up <a href="https://brm.io/matter-js/">Matter.js</a>. I decided to keep it simpler with a two-dimensional solution. This being the first time I&#8217;ve built anything physics related, three-dimensions felt like too complicated. Matter.js looked like it&#8217;d be able to build the virtual world I needed to throw apples&nbsp;in.</p>
<p>I copied over <a href="https://github.com/liabru/matter-js/wiki/Getting-started">some starter code</a> and was able to get something running in my local web browser within&nbsp;minutes.</p>
<p>With this, I had built a very simple two boxes falling to the ground. This is already almost exactly what I&nbsp;envisioned!</p>
<p><img data-src="/images/objects-container/step1.gif" width="640px" class="uk-align-center" uk-img/></p>
<h3>What does one put in a&nbsp;container?</h3>
<p>If we&#8217;re going to simulate apple slices, or any objects, falling into the container, we need to create those objects. To do so, I wrote the following function for building some very minimal&nbsp;boxes.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">box_width</span> <span class="o">=</span> <span class="mf">325</span><span class="p">,</span> <span class="nx">box_height</span> <span class="o">=</span> <span class="mf">70</span><span class="p">;</span>

<span class="c1">// create boxes and bounds</span>
<span class="kd">function</span> <span class="nx">buildBoxes</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">boxes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">random_x</span> <span class="o">=</span> <span class="mf">10</span> <span class="o">+</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">640</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">box</span> <span class="o">=</span> <span class="nx">Matter</span><span class="p">.</span><span class="nx">Bodies</span><span class="p">.</span><span class="nx">rectangle</span><span class="p">(</span>
            <span class="nx">random_x</span><span class="p">,</span>
            <span class="mf">40</span> <span class="o">*</span> <span class="nx">i</span><span class="p">,</span>
            <span class="nx">box_width</span><span class="p">,</span>
            <span class="nx">box_height</span><span class="p">,</span>
            <span class="p">{</span> <span class="nx">restitution</span><span class="o">:</span> <span class="mf">0.05</span><span class="p">,</span> <span class="nx">slop</span><span class="o">:</span> <span class="mf">0.0</span> <span class="p">}</span>
        <span class="p">);</span>
        <span class="nx">Body</span><span class="p">.</span><span class="nx">setDensity</span><span class="p">(</span><span class="nx">box</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
        <span class="nx">boxes</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">box</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">(</span><span class="nx">boxes</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">boxes</span> <span class="o">=</span> <span class="nx">buildBoxes</span><span class="p">(</span><span class="mf">7</span><span class="p">);</span>
</code></pre></div>

<p>I first define a width and height of the &#8220;apple slices&#8221;. Obviously these don&#8217;t mimic the shape of actual cross-sectional apple slice drawings, but it&#8217;s a first&nbsp;approximation.</p>
<p>In the function, we make an array of <code>boxes</code>. We add a certain <code>count</code> of boxes, and to do so, we need an <code>x</code> and <code>y</code> coordinate to put it at. We just randomly put the box on the x-axis of the virtual world, inset a little bit from the edges. And we put each successive box increasingly further down the screen (Matter.js has a <code>(0, 0)</code> coordinate in the top&nbsp;left).</p>
<p>We also set a couple properties of the boxes to help them &#8220;bounce&#8221; around like &#8220;actual&#8221; apple slices. Namely, <a href="https://brm.io/matter-js/docs/classes/Body.html#property_restitution">restitution</a>, which is basically how elastic objects colliding is, and <a href="https://brm.io/matter-js/docs/classes/Body.html#property_slop">slop</a>, which allows objects to &#8220;sink&#8221; into each other upon&nbsp;collision.</p>
<p>We also set the density of the objects so they collide and fall a bit more realistically. Finally, we <code>push</code> the newly created box to our&nbsp;array.</p>
<p>In the end, we create seven of these boxes, because somehow I decided that we usually cut apples into seven&nbsp;slices.</p>
<p>Now when I add these shapes to the <code>Composite</code>:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// add all of the bodies to the world</span>
<span class="nx">Composite</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">engine</span><span class="p">.</span><span class="nx">world</span><span class="p">,</span> <span class="p">[...</span><span class="nx">boxes</span><span class="p">,</span> <span class="nx">ground</span><span class="p">]);</span>
</code></pre></div>

<p>I get something that looks like the following (although random variation in the <code>x</code> positioning makes each run a little&nbsp;different):</p>
<p><img data-src="/images/objects-container/step2.gif" width="640px" class="uk-align-center" uk-img/></p>
<h3>Apples all over the&nbsp;counter</h3>
<p>The previous step is more like throwing apples all over the counter, instead of in a container. It&#8217;s easy to add new bounds to our virtual world to model a&nbsp;container.</p>
<p>Simply&nbsp;add:</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">wallL</span> <span class="o">=</span> <span class="nx">Bodies</span><span class="p">.</span><span class="nx">rectangle</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">160</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">640</span><span class="p">,</span> <span class="p">{</span> <span class="nx">isStatic</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>
<span class="kd">var</span> <span class="nx">wallR</span> <span class="o">=</span> <span class="nx">Bodies</span><span class="p">.</span><span class="nx">rectangle</span><span class="p">(</span><span class="mf">640</span><span class="p">,</span> <span class="mf">160</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">640</span><span class="p">,</span> <span class="p">{</span> <span class="nx">isStatic</span><span class="o">:</span> <span class="kc">true</span> <span class="p">});</span>

<span class="kd">var</span> <span class="nx">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="nx">ground</span><span class="p">,</span> <span class="nx">wallL</span><span class="p">,</span> <span class="nx">wallR</span><span class="p">];</span>
</code></pre></div>

<p>I found it difficult figuring out the numbers to use as arguments. If we were being more methodical, we might have set parameters at the top of our script to define, for example, the width of the screen to then be used in places like&nbsp;this.</p>
<p>Adding these bounds, along with the boxes, to the Composite gives us something like&nbsp;this:</p>
<p><img data-src="/images/objects-container/step3.gif" width="640px" class="uk-align-center" uk-img/></p>
<h2>Measuring how packed the container&nbsp;is</h2>
<p>Ultimately I&#8217;m interested in measuring how packed our container gets. This way we can vary the dimensions of our apple slices (boxes) and measure the height that all that apple stacks up. I&#8217;m predicting that smaller pieces will pack more densely than larger pieces. To begin, we need to measure the height of the pieces, and then record that&nbsp;height.</p>
<h3>Trigonemtry and rotated apple&nbsp;slices</h3>
<p>The first solution I had was to draw a line on top of all the boxes. I wasn&#8217;t sure of the best way to do this. At first I tried to do it with Matter.js Bodies. The goal was to place a constantly flat Body on top of everything, in a way that sort of &#8220;compressed&#8221; the boxes (but actually did not interact with them at&nbsp;all).</p>
<p>I needed at the very least a <code>y</code> value of the top-most point of all boxes. The way I approached this was to iterate over each box on every tick of the engine&#8217;s clock, and calculate the heighest corner of each box. Then look for the highest across boxes&nbsp;too.</p>
<p>It looks like&nbsp;this:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">line_y</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">hypo</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sqrt</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nx">box_width</span><span class="p">,</span> <span class="mf">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nx">box_height</span><span class="p">,</span> <span class="mf">2</span><span class="p">));</span>
<span class="kd">let</span> <span class="nx">box_theta</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">atan</span><span class="p">(</span><span class="nx">box_height</span> <span class="o">/</span> <span class="nx">box_width</span><span class="p">);</span>

<span class="nx">Events</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="nx">runner</span><span class="p">,</span> <span class="s2">&quot;tick&quot;</span><span class="p">,</span> <span class="nx">event</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">ys</span> <span class="o">=</span> <span class="nx">boxes</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">box</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">box_y</span> <span class="o">=</span> <span class="nx">box</span><span class="p">.</span><span class="nx">position</span><span class="p">.</span><span class="nx">y</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">box_rads</span> <span class="o">=</span> <span class="nx">box</span><span class="p">.</span><span class="nx">angle</span><span class="p">;</span>

        <span class="kd">let</span> <span class="nx">y_primes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="nx">box_y</span> <span class="o">+</span> <span class="nx">hypo</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">box_rads</span> <span class="o">-</span> <span class="nx">box_theta</span><span class="p">)</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span>
            <span class="nx">box_y</span> <span class="o">+</span> <span class="nx">hypo</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">box_rads</span> <span class="o">+</span> <span class="nx">box_theta</span><span class="p">)</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span>
            <span class="nx">box_y</span> <span class="o">+</span> <span class="nx">hypo</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">*</span><span class="nx">box_rads</span> <span class="o">-</span> <span class="nx">box_theta</span><span class="p">)</span><span class="o">/</span><span class="mf">2</span><span class="p">,</span>
            <span class="nx">box_y</span> <span class="o">+</span> <span class="nx">hypo</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="o">-</span><span class="mf">1</span><span class="o">*</span><span class="nx">box_rads</span> <span class="o">+</span> <span class="nx">box_theta</span><span class="p">)</span><span class="o">/</span><span class="mf">2</span>
        <span class="p">];</span>

        <span class="kd">let</span> <span class="nx">new_y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(...</span><span class="nx">y_primes</span><span class="p">);</span>

        <span class="k">return</span><span class="p">(</span><span class="nx">new_y</span><span class="p">);</span>
    <span class="p">})</span>

    <span class="nx">line_y</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(...</span><span class="nx">ys</span><span class="p">);</span>

<span class="p">});</span>
</code></pre></div>

<p>There might be a more efficient way of doing this, but for this article it works just fine and is easy to understand. To walk through it though, first off I want to establish a new variable for our <code>line_y</code>. This will hold the value of the top-most point of our apple slices. I also precompute two values: the <code>hypo</code>tenuse of each box, and the angle from the mid-point of the box to the corner (<span class="math">\(r\)</span>). These requires some basic trigonometry, which I <em>always</em> struggle with and <em>always</em> end up going to Kailyn and the internet for&nbsp;help.</p>
<p>Then I have an event handler attached to <code>runner</code>. This says, on each virtual time tick of the runner, run the following&nbsp;function.</p>
<p>In that anonymous function, I start off by creating a variable to hold our <code>ys</code> values. To populate this array, we iterate over each <code>box</code> in <code>boxes</code>. For each box, I store it&#8217;s current <code>y</code> value, or the distance from the top of the virtual environment to the mid-point of the box. I also store the angle of the box (<span class="math">\(\theta\)</span>), in&nbsp;radians.</p>
<p>The most math-y part of this all is finally here. I am calculating the y-value for each of the box&#8217;s four corners. That way I can determine which one is the highest. To do this, I add the mid-point of the box&#8217;s <code>y</code> value to the vertical distance between that mid-point and each corner (<span class="math">\(h\)</span>). This distance is dependent on the rotation of the box (<span class="math">\(\theta + r\)</span>). These calculations correspond to the following&nbsp;illustration:</p>
<p><img data-src="/images/objects-container/illustration1.gif" width="640px" class="uk-align-center" uk-img/></p>
<p>You&#8217;ll notice how we&#8217;re taking the minimum. Again, this is because the 0 of the y-axis is at the top of the&nbsp;screen.</p>
<h3>Visualizing the highest&nbsp;point</h3>
<p>To help debug and also as a nice visual aid, I needed a line of some sort that tracks this changing <code>line_y</code> computations. I tried to do this with Matter.js Bodies, but that didn&#8217;t work. I think those shapes tend to be reserved for objects that have some collision possibility. My line technically won&#8217;t collide with anything. So in that case, I found a way to draw on <a href="https://brm.io/matter-js/docs/classes/Render.html#property_canvas">the <span class="caps">HTML</span> canvas</a> generated by&nbsp;Matter.js.</p>
<p>I&#8217;ve had to change the dimensions of the box just a little so that the boxes fall nicely and aren&#8217;t overlapping when they&#8217;re drawn. To display a line at the top of the boxes though we&nbsp;need:</p>
<div class="highlight"><pre><span></span><code><span class="nx">Events</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="nx">render</span><span class="p">,</span> <span class="s2">&quot;afterRender&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">ctx</span> <span class="o">=</span> <span class="nx">render</span><span class="p">.</span><span class="nx">context</span><span class="p">;</span>

    <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineWidth</span> <span class="o">=</span> <span class="mf">4</span><span class="p">;</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">strokeStyle</span> <span class="o">=</span> <span class="s2">&quot;red&quot;</span><span class="p">;</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span> <span class="c1">// Start a new path</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="nx">line_y</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineTo</span><span class="p">(</span><span class="mf">640</span><span class="p">,</span> <span class="nx">line_y</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">stroke</span><span class="p">();</span>
<span class="p">})</span>
</code></pre></div>

<p>Hopefully this is pretty self-explanatory. All together, we have the&nbsp;following:</p>
<p><img data-src="/images/objects-container/step4.gif" width="640px" class="uk-align-center" uk-img/></p>
<p>There are two things remaining though: the repeated simulation aspect, and the&nbsp;recording.</p>
<h2>Repeating the simulation ad&nbsp;infinitum</h2>
<p>My goal is to compare how well small pieces fit compared to large pieces. It would be helpful if I could simulate throwing apple slices into the container many, many times to collect&nbsp;evidence.</p>
<p>To do this, I set an arbitrary threshold to determine when all the boxes have settled, and then we just redraw the canvas with new boxes. To really take advantage of the fact that this is a computer simulation, we&#8217;ll also increase the speed of the physics engine (i.e. make time go&nbsp;faster).</p>
<p>Back in our tick event listener, right after we compute the <code>ys</code> we&#8217;ll figure out if the line has&nbsp;settled:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span> <span class="p">(</span><span class="nx">tick_delay</span> <span class="o">==</span> <span class="mf">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">line_y</span> <span class="o">-</span> <span class="nx">prev_line_y</span> <span class="o">&lt;</span> <span class="nx">eps</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// the line has stopped</span>
    <span class="p">}</span>

    <span class="nx">tick_delay</span> <span class="o">=</span> <span class="nx">tick_max_delay</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">tick_delay</span> <span class="o">-=</span> <span class="mf">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">prev_line_y</span> <span class="o">=</span> <span class="nx">line_y</span><span class="p">;</span>
<span class="c1">// after this comes: line_y = Math.min(...ys);</span>
</code></pre></div>

<p>Above of the tick event listener, we define the delay variables&nbsp;here.</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span> <span class="nx">tick_max_delay</span> <span class="o">=</span> <span class="mf">120</span><span class="o">/</span><span class="nx">engine</span><span class="p">.</span><span class="nx">timing</span><span class="p">.</span><span class="nx">timeScale</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">tick_delay</span> <span class="o">=</span> <span class="nx">tick_max_delay</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">eps</span> <span class="o">=</span> <span class="mf">0.0001</span>
</code></pre></div>

<p>We&#8217;ll get to it in a moment, but the <code>engine.timing.timeScale</code> is basically a factor determining how fast time progresses. Less than 1 is like slow motion, greater than 1 is time sped up. The 120 here is just an arbitrary number I came up with through trial and error. It basically controls how often to check if the line has settled. It&#8217;s the number of frames/ticks that&nbsp;pass.</p>
<p>Back in the logic, the code first checks if <code>tick_delay</code> is 0. If it is, which means it&#8217;s time to check how settled the boxes are, the code looks to see if the difference between the red line&#8217;s y-value now, compared to the last time we checked, is less than <code>eps</code> units. If it is, that would indicate the line has settled and we should restart the simulation. If it&#8217;s not yet time to check the line, we just decrease the tick counter until it is&nbsp;time.</p>
<p>Now, where I commented <code>// the line has stopped</code> we&#8217;ll fill in&nbsp;with:</p>
<div class="highlight"><pre><span></span><code><span class="nx">Composite</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">engine</span><span class="p">.</span><span class="nx">world</span><span class="p">,</span> <span class="nx">boxes</span><span class="p">);</span>
<span class="nx">line_y</span> <span class="o">=</span> <span class="mf">0</span><span class="p">,</span> <span class="nx">prev_line_y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1000</span><span class="p">;</span>

<span class="nx">boxes</span> <span class="o">=</span> <span class="nx">buildBoxes</span><span class="p">(</span><span class="mf">7</span><span class="p">);</span>
<span class="nx">Composite</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">engine</span><span class="p">.</span><span class="nx">world</span><span class="p">,</span> <span class="nx">boxes</span><span class="p">);</span>
</code></pre></div>

<p>This is just code I already wrote. First I remove all the existing boxes from the engine&#8217;s virtual world. We make sure not to remove the bounds. Then we reset the line&#8217;s position. Then we draw new boxes, and finally we add those new boxes into the&nbsp;world.</p>
<p>Altogether it looks like the&nbsp;following:</p>
<p><img data-src="/images/objects-container/step5.gif" width="640px" class="uk-align-center" uk-img/></p>
<p>It might not be exactly perfect, or exactly fine-tuned, but it&#8217;s good&nbsp;enough.</p>
<h3>Let&#8217;s do the time&nbsp;warp</h3>
<p>I said we&#8217;d get back to time scale part. In Matter.js, you can control how quickly time passes with the <code>timing</code> option of the <code>engine</code>. So, for example, after we create our engine, we&nbsp;have:</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nx">engine</span> <span class="o">=</span> <span class="nx">Engine</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
<span class="nx">engine</span><span class="p">.</span><span class="nx">timing</span><span class="p">.</span><span class="nx">timeScale</span> <span class="o">=</span> <span class="mf">4</span><span class="p">;</span>
</code></pre></div>

<p>This now speeds up the simulation to 4x speed! Here&#8217;s what that looks&nbsp;like:</p>
<p><img data-src="/images/objects-container/step6.gif" width="640px" class="uk-align-center" uk-img/></p>
<h3>Recording the height for later&nbsp;analysis</h3>
<p>Just before we remove the boxes from the screen, I wanted to record the value of <code>line_y</code> so that we could collect some data. Remember, this is all running right in an <span class="caps">HTML</span> file so we don&#8217;t have any file writing capabilities. That&#8217;s okay though, for my intents I&#8217;ll just write the data to the <span class="caps">DOM</span>.</p>
<p>Above our script tags in the <span class="caps">HTML</span> body itself, I added a <code>table</code> container: <code>&lt;table id="data"&gt;&lt;/table&gt;</code>. And then in the <span class="caps">JS</span>, just before removing the boxes, I&nbsp;added:</p>
<div class="highlight"><pre><span></span><code><span class="nx">data_counter</span> <span class="o">+=</span> <span class="mf">1</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">+=</span> <span class="s1">&#39;&lt;tr&gt;&lt;td&gt;&#39;</span> <span class="o">+</span> <span class="nx">data_counter</span> <span class="o">+</span> <span class="s1">&#39;&lt;/td&gt;&lt;td&gt;&#39;</span> <span class="o">+</span> <span class="p">(</span><span class="mf">480</span> <span class="o">-</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nx">line_y</span><span class="o">*</span><span class="mf">100</span><span class="p">)</span><span class="o">/</span><span class="mf">100</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&lt;/td&gt;&lt;/tr&gt;&#39;</span>
</code></pre></div>

<p>Super easy to add these numbers as data, which we can just copy/paste into a&nbsp;spreadsheet.</p>
<p><img data-src="/images/objects-container/step7.gif" width="640px" class="uk-align-center" uk-img/></p>
<h2>Empirically packing apple slice&nbsp;containers</h2>
<p>The question now is, if we simulate some number of throws of large apple slices and some number of throws of small apple slices, will the smaller pieces on average condense further in the&nbsp;container?</p>
<p>Our big apple slices are boxes with width 325 units and height 70 units, and we draw 7 of them. Thus, our small slices (let&#8217;s just say we cut the big ones in half) will be 163 units by 70 units, and we&#8217;ll draw 14 of&nbsp;them.</p>
<p>How many simulations should we run of each? First, I need to decide what will provide me with evidence that smaller slices pack better. I don&#8217;t actually know if the distribution of <code>y</code> values will be normally distributed. So, in that case, I&#8217;ll run two tests to empirically decide if smaller pieces fit better. I&#8217;ll run a one-sided <i>t</i>-test with unequal variances, and a non-parametric one-sided Mann-Whitney&nbsp;test.</p>
<p>I want to collect enough data so that I&#8217;m 90% sure that if smaller pieces actually do pack better that we&#8217;ll identify that difference. Simulations are relatively cheap; they just take time, so I can afford to increase this percentage (i.e. power) fairly&nbsp;high.</p>
<p>Second, I want to be sure not have a false positive here since I only want to do this test once. I&#8217;ll set my Type I error threshold to 0.01 (i.e. 1% of tests will be false&nbsp;positives).</p>
<p>I&#8217;m going to consider two different effect sizes before computing the required sample size to reject our null hypotheses. These include the smallest effect size I&#8217;m interested in detecting and also the expected effect size. A very wonderful resource that I leaned heavily on for this section is DaniÃ«l Lakens&#8217; <a href="https://lakens.github.io/statistical_inferences/08-samplesizejustification.html">Improving Your Statistical Inferences</a> online&nbsp;textbook.</p>
<h3>Determining effect sizes and sample&nbsp;sizes</h3>
<p>I figure the smallest effect size of interest here (the standardized difference between two groups) is around <i>d</i>=0.5. In other words, the average difference between how packed large and small boxes will get is around one-half of a standard&nbsp;deviation.</p>
<p>What I expect though is that small boxes will condense quite a bit more than large boxes. I&#8217;m going to say that the average difference of the means will be roughly a whole standard&nbsp;deviation.</p>
<p>Assuming that the data are log-normally distributed (very slightly), using a Mann-Whitney <i>U</i> test I figure I need about 160 observations per condition to detect a difference between these&nbsp;distributions.</p>
<div class="highlight"><pre><span></span><code><span class="n">R</span> <span class="o">&lt;-</span> <span class="m">2000</span>
<span class="n">size</span> <span class="o">&lt;-</span> <span class="m">160</span>
<span class="n">p</span> <span class="o">&lt;-</span> <span class="nf">numeric</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="n">d</span> <span class="o">&lt;-</span> <span class="nf">numeric</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="nf">for </span><span class="p">(</span><span class="n">i</span> <span class="n">in</span> <span class="m">1</span><span class="o">:</span><span class="n">R</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">large</span> <span class="o">&lt;-</span> <span class="nf">rlnorm</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nf">log</span><span class="p">(</span><span class="m">400</span><span class="p">),</span> <span class="m">0.7</span><span class="p">)</span>
    <span class="n">small</span> <span class="o">&lt;-</span> <span class="nf">rlnorm</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nf">log</span><span class="p">(</span><span class="m">300</span><span class="p">),</span> <span class="m">0.7</span><span class="p">)</span>

    <span class="c1"># t &lt;- t.test(large, small,</span>
    <span class="c1">#                alternative = &quot;g&quot;,</span>
    <span class="c1">#                var.equal = F)</span>

    <span class="n">t</span> <span class="o">&lt;-</span> <span class="nf">wilcox.test</span><span class="p">(</span><span class="n">large</span><span class="p">,</span> <span class="n">small</span><span class="p">,</span> <span class="n">alternative</span> <span class="o">=</span> <span class="s">&quot;g&quot;</span><span class="p">)</span>

    <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="n">t</span><span class="o">$</span><span class="n">p.value</span>
    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;-</span> <span class="nf">as.numeric</span><span class="p">(</span><span class="n">effectsize</span><span class="o">::</span><span class="nf">r_to_d</span><span class="p">(</span><span class="n">effectsize</span><span class="o">::</span><span class="nf">effectsize</span><span class="p">(</span><span class="n">t</span><span class="p">)))[</span><span class="m">1</span><span class="p">]</span>
<span class="p">}</span>
<span class="nf">summary</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</code></pre></div>

<pre class="code-output">
    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
0.09244 0.38156 0.46996 0.47423 0.56070 1.00036
</pre>

<p>As we can see, our toy data has a simulated average effect size of <i>d</i>=0.47, which is close enough to the smallest effect size of interest I want to capture. If the real effect size were smaller, it wouldn&#8217;t be interesting to us, and if it&#8217;s bigger we&#8217;ll catch it with this sample&nbsp;size.</p>
<p>These sample sizes with this average difference would give us 90% power&nbsp;too:</p>
<div class="highlight"><pre><span></span><code><span class="nf">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">&lt;</span> <span class="m">0.01</span><span class="p">)</span> <span class="o">/</span> <span class="n">R</span>
</code></pre></div>

<pre class="code-output">0.9</pre>

<p>About 40-45 samples per condition would be needed to detect a difference in Cohen&#8217;s <i>d</i> of&nbsp;1.0.</p>
<p>With an estimated Cohen&#8217;s <i>d</i> of 0.5 for a <i>t</i>-test, the required sample size to detect a difference with 90% power is 95 observations per sample (for both large boxes and small boxes). For a Cohen&#8217;s <i>d</i> of 1.0, I&#8217;d need 32 observations per&nbsp;sample.</p>
<p>Unsurprisingly, the nonparametric test requires a greater sample size to detect a&nbsp;difference.</p>
<p>Let&#8217;s go simulate enough throws for have enough power to detect our smaller effect&nbsp;size.</p>
<h3>Exhausting my arm with all these&nbsp;throws</h3>
<p>Our simulation engine is great for throwing this many apple slices into the container. In total, I threw 320 apples (1,120 big slices, and 2,240 small slices). At $1.29 an apple (<a href="https://www.traderjoes.com/home/products/pdp/honeycrisp-apples-093872">thanks TJs</a>), that&#8217;s $412 worth of&nbsp;apples.</p>
<p>Let&#8217;s plot the distributions of <code>y</code> values.</p>
<p><img data-src="/images/objects-container/distribution.png" width="640px" alt="" class="uk-align-center" uk-img></p>
<p>Already it looks clear that smaller boxes pack better than larger boxes, but let&#8217;s run our tests to be&nbsp;sure.</p>
<h3>Do smaller objects fit better than larger&nbsp;ones?</h3>
<div class="highlight"><pre><span></span><code><span class="nf">wilcox.test</span><span class="p">(</span>
    <span class="n">line_y</span> <span class="o">~</span> <span class="n">experiment</span><span class="p">,</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">results</span><span class="p">,</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="s">&quot;g&quot;</span>
<span class="p">)</span>
</code></pre></div>

<pre class="code-output">
data:  line_y by experiment
W = 22785, p-value < 2.2e-16
</pre>

<p>and the stricter&nbsp;t-test:</p>
<div class="highlight"><pre><span></span><code><span class="nf">t.test</span><span class="p">(</span>
    <span class="n">line_y</span> <span class="o">~</span> <span class="n">experiment</span><span class="p">,</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">results</span><span class="p">,</span>
    <span class="n">alternative</span> <span class="o">=</span> <span class="s">&quot;g&quot;</span>
<span class="p">)</span>
</code></pre></div>

<pre class="code-output">
data:  line_y by experiment
t = 12.108, df = 251.73, p-value < 2.2e-16
</pre>

<p>Hardly a contest at all. Smaller boxes packed better than larger boxes, and there&#8217;s almost no chance that this was a mistake&nbsp;finding.</p>
<p>Lastly, through induction, I&#8217;ll make the generalized claim that yes, smaller objects will on average pack better in a container than larger&nbsp;objects.</p>
<h2>Isn&#8217;t this just&nbsp;integration?</h2>
<p>We really didn&#8217;t <em>need</em> to do any of this work in order to get an answer. What we&#8217;re doing is basically approximating the surface area of our apple slices more and more accurately the smaller the slice we have. This is akin to a <a href="https://en.wikipedia.org/wiki/Riemann_sum">Reimann sum</a> in two dimensions. For apple slices to be packed well in the container, that implies there&#8217;s no space in between slices. If there&#8217;s no space, then the question is just, how much apple is there? We&#8217;re working in two dimensions, so that can also be worded, what is the area of the apple&nbsp;slices?</p>
<p>If we knew of a function that, given some <span class="math">\(x\)</span> or <span class="math">\(y\)</span> value, would tell us what portion under that curve was apple, we would need to sum all of that function across our <span class="math">\(x\)</span> range and again over all the <span class="math">\(y\)</span> range. If that function is <span class="math">\(g(x, y)\)</span> then, analytically speaking, this makes the Riemann sum <a href="https://en.wikipedia.org/wiki/Riemann_sum#Connection_with_integration">equivalent</a> to definite Riemann&nbsp;integration:</p>
<div class="math">$$
\int_{y_{min}}^{y_{max}} \int_{x_{min}}^{x_{max}} g(x, y)\enspace dx dy = \lim_{\Delta x, \Delta y \to 0} \sum_{j = 1}^n \sum_{i = 1}^n g(x_{ij}, y_{ij}) \Delta x_i \Delta y_j
$$</div>
<p>If <span class="math">\(\Delta x\)</span> or <span class="math">\(\Delta y\)</span> are large, then this is a poor approximation of the actual <span class="math">\(g(x, y)\)</span> since there&#8217;s so much space between the curve and the rectangles. However they are small, perhaps infinitely small, then we get a very good approximation of the curve (i.e. a good approximation of how much surface area the apple slices&nbsp;are).</p>
<p>If we step back a moment, we&#8217;ll actually realize then that small is better, although the improvements are decreasing as we reduce the slice size. At a certain point, especially in the real world, improvements in approximating the surface area function just aren&#8217;t worth the decrease in size necessary. We can cut the apple slices smaller and smaller, and yes they will pack into the container better and better, but eventually you either A) won&#8217;t be able to cut any smaller or B) will turn your apple into&nbsp;pulp.</p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
  </div>
</section>
       <footer class="uk-section">
              <div class="uk-container uk-width-2-3@m uk-margin-auto">
                     <address>
                            <a href="/pages/copyright.html">Â© 2024 Alex Liebscher</a> | Powered by <a
                                   href="https://getpelican.com/">Pelican</a>.
                     </address>
              </div>
       </footer>
</body>

</html>